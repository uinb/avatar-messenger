
pub use trie_db::{
    proof::{generate_proof, verify_proof},
    Trie, TrieMut, DBValue, Recorder, CError, Query, TrieLayout, TrieConfiguration, nibble_ops, TrieDBIterator,
};
pub use trie_db::proof::VerifyError;
use hash_db::{HashDB,Hasher};
use crate::trie_stream::TrieStream;
use crate::node_codec::NodeCodec;
use crate::error::Error;
use std::borrow::Borrow;


#[cfg(not(feature = "memory-tracker"))]
type MemTracker = memory_db::NoopTracker<trie_db::DBValue>;
#[cfg(feature = "memory-tracker")]
type MemTracker = memory_db::MemCounter<trie_db::DBValue>;

pub type TrieError<L> = trie_db::TrieError<TrieHash<L>, CError<L>>;
pub type MemoryDB<H> = memory_db::MemoryDB<
    H, memory_db::HashKey<H>, trie_db::DBValue, MemTracker,
>;
pub struct Layout<H>(std::marker::PhantomData<H>);
/// Hash type for a trie layout.
pub type TrieHash<L> = <<L as TrieLayout>::Hash as Hasher>::Out;
/// Persistent trie database read-access interface for the a given hasher.
pub type TrieDB<'a, L> = trie_db::TrieDB<'a, L>;
/// Persistent trie database write-access interface for the a given hasher.
pub type TrieDBMut<'a, L> = trie_db::TrieDBMut<'a, L>;

impl<H: Hasher> TrieLayout for Layout<H> {
    const USE_EXTENSION: bool = false;
    const ALLOW_EMPTY: bool = true;
    type Hash = H;
    type Codec = NodeCodec<Self::Hash>;
}


/// This module is for non generic definition of trie type.
/// Only the `Hasher` trait is generic in this case.
pub mod trie_types {
    pub type Layout<H> = super::Layout<H>;
    /// Persistent trie database read-access interface for the a given hasher.
    pub type TrieDB<'a, H> = super::TrieDB<'a, Layout<H>>;
    /// Persistent trie database write-access interface for the a given hasher.
    pub type TrieDBMut<'a, H> = super::TrieDBMut<'a, Layout<H>>;
    /// Querying interface, as in `trie_db` but less generic.
    pub type Lookup<'a, H, Q> = trie_db::Lookup<'a, Layout<H>, Q>;
    /// As in `trie_db`, but less generic, error type for the crate.
    pub type TrieError<H> = trie_db::TrieError<H, super::Error>;
}

impl<H: Hasher> TrieConfiguration for Layout<H> {
    fn trie_root<I, A, B>(input: I) -> <Self::Hash as Hasher>::Out where
        I: IntoIterator<Item = (A, B)>,
        A: AsRef<[u8]> + Ord,
        B: AsRef<[u8]>,
    {
        trie_root::trie_root_no_extension::<H, TrieStream, _, _, _>(input)
    }

    fn trie_root_unhashed<I, A, B>(input: I) -> Vec<u8> where
        I: IntoIterator<Item = (A, B)>,
        A: AsRef<[u8]> + Ord,
        B: AsRef<[u8]>,
    {
        trie_root::unhashed_trie_no_extension::<H, TrieStream, _, _, _>(input)
    }

    fn encode_index(input: u32) -> Vec<u8> {
        codec::Encode::encode(&codec::Compact(input))
    }
}


pub fn generate_trie_proof<'a, L: TrieConfiguration, I, K, DB>(
    db: &DB,
    root: TrieHash<L>,
    keys: I,
) -> Result<Vec<Vec<u8>>, Box<TrieError<L>>> where
    I: IntoIterator<Item=&'a K>,
    K: 'a + AsRef<[u8]>,
    DB: hash_db::HashDBRef<L::Hash, trie_db::DBValue>,
{
    let trie = TrieDB::<L>::new(db, &root)?;
    generate_proof(&trie, keys)
}

/// Verify a set of key-value pairs against a trie root and a proof.
///
/// Checks a set of keys with optional values for inclusion in the proof that was generated by
/// `generate_trie_proof`.
/// If the value in the pair is supplied (`(key, Some(value))`), this key-value pair will be
/// checked for inclusion in the proof.
/// If the value is omitted (`(key, None)`), this key will be checked for non-inclusion in the
/// proof.
pub fn verify_trie_proof<'a, L: TrieConfiguration, I, K, V>(
    root: &TrieHash<L>,
    proof: &[Vec<u8>],
    items: I,
) -> Result<(), VerifyError<TrieHash<L>, Error>> where
    I: IntoIterator<Item=&'a (K, Option<V>)>,
    K: 'a + AsRef<[u8]>,
    V: 'a + AsRef<[u8]>,
{
    verify_proof::<Layout<L::Hash>, _, _, _>(root, proof, items)
}


#[cfg(test)]
mod tests {
    use super::*;
    use codec::{Encode, Decode, Compact};
    use sp_core::Blake2Hasher;
    use hash_db::{HashDB, Hasher};
    use trie_db::{DBValue, TrieMut, Trie, NodeCodec as NodeCodecT};
    use trie_standardmap::{Alphabet, ValueMode, StandardMap};
    use hex_literal::hex;

    type Layout = super::Layout<Blake2Hasher>;


    fn populate_trie<'db, T: TrieConfiguration>(
        db: &'db mut dyn HashDB<T::Hash, DBValue>,
        root: &'db mut TrieHash<T>,
        v: &[(Vec<u8>, Vec<u8>)]
    ) -> TrieDBMut<'db, T> {
        let mut t = TrieDBMut::<T>::new(db, root);
        for i in 0..v.len() {
            let key: &[u8]= &v[i].0;
            let val: &[u8] = &v[i].1;
            t.insert(key, val);
        }
        t
    }


    #[test]
    fn proof_non_inclusion_works() {
        let pairs = vec![
            (hex!("0102").to_vec(), hex!("01").to_vec()),
            (hex!("0203").to_vec(), hex!("0405").to_vec()),
        ];

        let mut memdb = MemoryDB::default();
        let mut root: TrieHash<Layout> = Default::default();
        populate_trie::<Layout>(&mut memdb, &mut root, &pairs);

        let non_included_key: Vec<u8> = hex!("0909").to_vec();
        let proof = generate_trie_proof::<Layout, _, _, _>(
            &memdb,
            root,
            &[non_included_key.clone()]
        ).unwrap();

        // Verifying that the K was not included into the trie should work.
        assert!(verify_trie_proof::<Layout, _, _, Vec<u8>>(
            &root,
            &proof,
            &[(non_included_key.clone(), None)],
        ).is_ok()
        );

        // Verifying that the K was included into the trie should fail.
        assert!(verify_trie_proof::<Layout, _, _, Vec<u8>>(
            &root,
            &proof,
            &[(non_included_key, Some(hex!("1010").to_vec()))],
        ).is_err()
        );
    }

   /* #[test]
    fn proof_non_inclusion_works1() {
        let pairs = vec![
            (hex!("00").to_vec(), hex!("280402000b20a1ff837d01").to_vec()),
            (hex!("04").to_vec(), hex!("dd1a8400c6c08b37336550c0d64f1e24e38b72e2c627c5b15aa3ce7f42a2069aed74277201828639f26b7412188dff32856d78fcf1592deabf73ff4ed1651493bb5837cb6977f9e3c24e03a23acbfb9e1a9c283c8aeaf52599df1266d7452367220d351289007540000d01340c000000000000b4efe738ad9b5ec63d4b07b9cf6674fc0b5b5054847d742e7880e87cae5e2563549c00000101169d796416023558ef5c2580ef38c1c4f43f3c06f76ceab2412e6fc5d486a36eb0a9cb808dd4eb72f6264b4113c1a722479be205edc84d6ac5403d33d09b008701110600130000f44482916345a10fa10f000414240100000000010000000000d6ebfc1ca5f8800000000000000000009ea2c6486f6701000000000000000000e2a67a8b41b3800000000000000000009ea2c6486f6701000000000000009400fc15c27a022529b9e1402cac8dff2852119efa008fecc2ec5a1f189356b8691b000000000040b254edfe33ea14170000000000000000bcf0b5fcbebf80000000000000000040b254edfe33ea14170000000000000000c8ab336b5b7a80000000000000009400fc15c27a022529b9e1402cac8dff2852119efa008fecc2ec5a1f189356b8691b0100000000c489b9d1d659b06a030000000000000000000000000000000000000000000000c49185d403f255ce03000000000000000000000000000000000000000000009400b4efe738ad9b5ec63d4b07b9cf6674fc0b5b5054847d742e7880e87cae5e25630000000032806de53ea57167c71100000000000000000000000000000000000000000000320081f24773c3acc711000000000000000000000000000000000000000000009400b4efe738ad9b5ec63d4b07b9cf6674fc0b5b5054847d742e7880e87cae5e25630100000000d095b6c0efa898af000000000000000000000000000000000000000000000000d0d5977dc487d94b00000000000000000000000000000000000000000000008d074c4ffd4c4ff951f917155e35806affd1bbb46ea95da82d59649616f41e294f6a06697c65c5191440720dfb4d483eeeef152d8ade5f45dab989f9b7995f87363e733ac995fe9a18014c4ffa484f0151fc9a06eda604e76b7ab67b050cbbc2ff5db101cf6c7b3f097dba6128c0a96df9970d90fd39484ce4fc3c77ffe804755b7cb207f4477251b4f6d56cd32468105405485038b4baa41e5ba50fc2a14ad27a74b47709685fcb42ad3b364c31809bd7efeda54c4ffb51fbe5b5dc28c4b3a08234e529e527952a0550696f66b075e565ad62ce2f6db26c0e6665efc9341cc6b8bcb83e54f01c21706f1ce842d6ef781ac893f8d2214eff01510243162b2ed9b65e3548015c1443a08cb09e5ae45226c4f738052c4210e22320db0000000000000000000000000000000000000000000000000000000000000004506d292bd982d68d5e369a9d9f490f9f7b09d4b8d0ce27b069e47b005bbf50fc4f4c4ffb51015337a1404fb6da9453ef4f55da6e54ed34498c125d9d8e3f2edcda4b3e9d2dcd00000000000000000000000000000000000000000000000000000000000000045043ba0e3da900b0641cbe6cfc438e3122fe62c0eda25b6b64bd31904a88e715fe50b49d76e889d15ae724a2f228e974e53e210330cc9a581f2f6bf0f3ac6471baf148488d074c4ffd4c4ff951f917155e35806affd1bbb46ea95da82d59649616f41e294f6a06697c65c5191440720dfb4d483eeeef152d8ade5f45dab989f9b7995f87363e733ac995fe9a18014c4ffa484f0151fc9a06eda604e76b7ab67b050cbbc2ff5db101cf6c7b3f097dba6128c0a96df9970d90fd39484ce4fc3c77ffe804755b7cb207f4477251b4f6d56cd32468105405485038b4baa41e5ba50fc2a14ad27a74b47709685fcb42ad3b364c31809bd7efeda54c4ffb51fbe5b5dc28c4b3a08234e529e527952a0550696f66b075e565ad62ce2f6db26c0e6665efc9341cc6b8bcb83e54f01c21706f1ce842d6ef781ac893f8d2214eff01510243162b2ed9b65e3548015c1443a08cb09e5ae45226c4f738052c4210e22320db0000000000000000000000000000000000000000000000000000000000000004506d292bd982d68d5e369a9d9f490f9f7b09d4b8d0ce27b069e47b005bbf50fc4f4c4ffb51015337a1404fb6da9453ef4f55da6e54ed34498c125d9d8e3f2edcda4b3e9d2dcd00000000000000000000000000000000000000000000000000000000000000045043ba0e3da900b0641cbe6cfc438e3122fe62c0eda25b6b64bd31904a88e715fe50b49d76e889d15ae724a2f228e974e53e210330cc9a581f2f6bf0f3ac6471baf14848bff86e730bfc6c184170b30d29ef3f44aa9a242a4baa8efe9c2c07e97771f837").to_vec()),
        ];

        let mut memdb = MemoryDB::default();
        let mut root: TrieHash<Layout> = Default::default();
        populate_trie::<Layout>(&mut memdb, &mut root, &pairs);

        println!("{:}",hex::encode(root));

        let non_included_key: Vec<u8> = hex!("00").to_vec();
        let proof = generate_trie_proof::<Layout, _, _, _>(
            &memdb,
            root,
            &[non_included_key.clone()]
        ).unwrap();


        // Verifying that the K was not included into the trie should work.
        assert!(verify_trie_proof::<Layout, _, _, Vec<u8>>(
            &root,
            &proof,
            &[(non_included_key.clone(), Some(hex!("280402000b20a1ff837d01").to_vec()))],
        ).is_ok()
        );

        // Verifying that the K was included into the trie should fail.
        assert!(verify_trie_proof::<Layout, _, _, Vec<u8>>(
            &root,
            &proof,
            &[(hex!("00").to_vec(), None)],
        ).is_ok()
        );
    }*/
}